#include <openssl/engine.h>

int openssl_engine_pkcs11_bind(ENGINE* e, const char* id);

/**
 * This is a shim around the engine bind function defined in Rust-land.
 *
 * It needs to be in C because exporting the bind function does not have a stable C API,
 * and can only be done through the IMPLEMENT_* macros. The macro expansion is also different for different openssl versions,
 * so it's not trivial to replicate in Rust.
 *
 * Rust emits a custom version script that only lists globals that rustc knows about.
 * So bind_engine and v_check generated by the above two macros will not be exported.
 *
 * It's not possible to provide a custom version script via `cargo:rustc-cdylib-link-arg`
 * because it conflicts with the one generated by rustc.
 *
 * So use the other way mentioned by `ld`'s docs, `__asm__(".symver")`
 */
IMPLEMENT_DYNAMIC_BIND_FN(openssl_engine_pkcs11_bind);
__asm__(".symver bind_engine,bind_engine@@");
IMPLEMENT_DYNAMIC_CHECK_FN();
__asm__(".symver v_check,v_check@@");



/**
 * These constants are defined as macros, so get them from C rather than hard-code them in Rust.
 */
unsigned int get_ENGINE_CMD_BASE() {
	return ENGINE_CMD_BASE;
}

unsigned int get_ENGINE_CMD_FLAG_STRING() {
	return ENGINE_CMD_FLAG_STRING;
}


/**
 * These functions are defined as functions in 1.0.0 and as macros in 1.1.0, so invoke them from C.
 *
 * Also take the opportunity to memoize them in C rather than in Rust.
 */
int get_engine_ex_index() {
	static int result = -1;

	if (result == -1) {
		// TODO: dupf, freef
		result = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, NULL);
	}

	return result;
}

void freef_ec_key_ex_data(void* parent, void* ptr, CRYPTO_EX_DATA* ad, int idx, long argl, void* argp);

int get_ec_key_ex_index() {
	static int result = -1;

	if (result == -1) {
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
		// TODO: dupf
		result = EC_KEY_get_ex_new_index(0, NULL, NULL, NULL, freef_ec_key_ex_data);
#else
		// TODO: dupf
		result = ECDSA_get_ex_new_index(0, NULL, NULL, NULL, freef_ec_key_ex_data);
#endif
	}

	return result;
}

void freef_rsa_ex_data(void* parent, void* ptr, CRYPTO_EX_DATA* ad, int idx, long argl, void* argp);

int get_rsa_ex_index() {
	static int result = -1;

	if (result == -1) {
		// TODO: dupf
		result = RSA_get_ex_new_index(0, NULL, NULL, NULL, freef_rsa_ex_data);
	}

	return result;
}
